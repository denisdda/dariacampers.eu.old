function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}
/**
 * @popperjs/core v2.4.4 - MIT License
 */!function(e,t){"object"===("undefined"==typeof exports?"undefined":_typeof(exports))&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).Popper={})}(this,(function(e){"use strict";function t(e){var t=e.getBoundingClientRect();return{width:t.width,height:t.height,top:t.top,right:t.right,bottom:t.bottom,left:t.left,x:t.left,y:t.top}}
/*:: import type { Window } from '../types'; */
/*:: declare function getWindow(node: Node | Window): Window; */function n(e){if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t?t.defaultView:window}return e}function r(e){var t=n(e);return{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}
/*:: declare function isElement(node: mixed): boolean %checks(node instanceof
    Element); */function o(e){return e instanceof n(e).Element||e instanceof Element}
/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
    HTMLElement); */function i(e){return e instanceof n(e).HTMLElement||e instanceof HTMLElement}function a(e){return e?(e.nodeName||"").toLowerCase():null}function s(e){
// $FlowFixMe: assume body is always available
return(o(e)?e.ownerDocument:e.document).documentElement}function f(e){
// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
// Popper 1 is broken in this case and never had a bug report so let's assume
// it's not an issue. I don't think anyone ever specifies width on <html>
// anyway.
// Browsers where the left scrollbar doesn't cause an issue report `0` for
// this (e.g. Edge 2019, IE11, Safari)
return t(s(e)).left+r(e).scrollLeft}function c(e){return n(e).getComputedStyle(e)}function p(e){
// Firefox wants us to check `-x` and `-y` variations as well
var t=c(e),n=t.overflow,r=t.overflowX,o=t.overflowY;return/auto|scroll|overlay|hidden/.test(n+o+r)}// Composite means it takes into account transforms as well as layout.
function l(e,o,c){void 0===c&&(c=!1);var l,u,d=s(o),m=t(e),h=i(o),b={scrollLeft:0,scrollTop:0},g={x:0,y:0};return(h||!h&&!c)&&(("body"!==a(o)||// https://github.com/popperjs/popper-core/issues/1078
p(d))&&(b=(l=o)!==n(l)&&i(l)?{scrollLeft:(u=l).scrollLeft,scrollTop:u.scrollTop}:r(l)),i(o)?((g=t(o)).x+=o.clientLeft,g.y+=o.clientTop):d&&(g.x=f(d))),{x:m.left+b.scrollLeft-g.x,y:m.top+b.scrollTop-g.y,width:m.width,height:m.height}}// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.
function u(e){return{x:e.offsetLeft,y:e.offsetTop,width:e.offsetWidth,height:e.offsetHeight}}function d(e){return"html"===a(e)?e:// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
e.assignedSlot||// step into the shadow DOM of the parent of a slotted node
e.parentNode||// DOM Element detected
// $FlowFixMe: need a better way to handle this...
e.host||// ShadowRoot detected
// $FlowFixMe: HTMLElement is a Node
s(e)}function m(e){return["html","body","#document"].indexOf(a(e))>=0?e.ownerDocument.body:i(e)&&p(e)?e:m(d(e))}
/*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the 
  reference element's position.
  */function h(e,t){void 0===t&&(t=[]);var r=m(e),o="body"===a(r),i=n(r),s=o?[i].concat(i.visualViewport||[],p(r)?r:[]):r,f=t.concat(s);return o?f:// $FlowFixMe: isBody tells us target will be an HTMLElement here
f.concat(h(d(s)))}function b(e){return["table","td","th"].indexOf(a(e))>=0}function g(e){if(!i(e)||// https://github.com/popperjs/popper-core/issues/837
"fixed"===c(e).position)return null;var t=e.offsetParent;if(t){var n=s(t);if("body"===a(t)&&"static"===c(t).position&&"static"!==c(n).position)return n}return t}// `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function v(e){for(var t=n(e),r=g(e);r&&b(r)&&"static"===c(r).position;)r=g(r);return r&&"body"===a(r)&&"static"===c(r).position?t:r||function(e){for(var t=d(e);i(t)&&["html","body"].indexOf(a(t))<0;){var n=c(t);// This is non-exhaustive but covers the most common CSS properties that
// create a containing block.
if("none"!==n.transform||"none"!==n.perspective||n.willChange&&"auto"!==n.willChange)return t;t=t.parentNode}return null}(e)||t}var y="top",w="bottom",x="right",O="left",j="auto",E=[y,w,x,O],S="start",M="end",P="viewport",D="popper",k=E.reduce((function(e,t){return e.concat([t+"-"+S,t+"-"+M])}),[]),q=[].concat(E,[j]).reduce((function(e,t){return e.concat([t,t+"-"+S,t+"-"+M])}),[]),L=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function A(e){var t=new Map,n=new Set,r=[];// On visiting object, check for its dependencies and visit them recursively
function o(e){n.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!n.has(e)){var r=t.get(e);r&&o(r)}})),r.push(e)}return e.forEach((function(e){t.set(e.name,e)})),e.forEach((function(e){n.has(e.name)||
// check for visited object
o(e)})),r}function T(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return[].concat(n).reduce((function(e,t){return e.replace(/%s/,t)}),e)}var B='Popper: modifier "%s" provided an invalid %s property, expected %s but got %s',W=["name","enabled","phase","fn","effect","requires","options"];function H(e){return e.split("-")[0]}function C(e,t){
// $FlowFixMe: hasOwnProperty doesn't seem to work in tests
var n=Boolean(t.getRootNode&&t.getRootNode().host);// First, attempt with faster native method
if(e.contains(t))return!0;// Give up, the result is false
if(n){var r=t;do{if(r&&e.isSameNode(r))return!0;// $FlowFixMe: need a better way to handle this...
r=r.parentNode||r.host}while(r)}return!1}function R(e){return Object.assign(Object.assign({},e),{},{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function I(e,o){return o===P?R(function(e){var t=n(e),r=s(e),o=t.visualViewport,i=r.clientWidth,a=r.clientHeight,c=0,p=0;// NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
// can be obscured underneath it.
// Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
// if it isn't open, so if this isn't available, the popper will be detected
// to overflow the bottom of the screen too early.
return o&&(i=o.width,a=o.height,// Uses Layout Viewport (like Chrome; Safari does not currently)
// In Chrome, it returns a value very close to 0 (+/-) but contains rounding
// errors due to floating point numbers, so we need to check precision.
// Safari returns a number <= 0, usually < -1 when pinch-zoomed
// Feature detection fails in mobile emulation mode in Chrome.
// Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
// 0.001
// Fallback here: "Not Safari" userAgent
/^((?!chrome|android).)*safari/i.test(navigator.userAgent)||(c=o.offsetLeft,p=o.offsetTop)),{width:i,height:a,x:c+f(e),y:p}}// of the `<html>` and `<body>` rect bounds if horizontally scrollable
(e)):i(o)?function(e){var n=t(e);return n.top=n.top+e.clientTop,n.left=n.left+e.clientLeft,n.bottom=n.top+e.clientHeight,n.right=n.left+e.clientWidth,n.width=e.clientWidth,n.height=e.clientHeight,n.x=n.left,n.y=n.top,n}(o):R(function(e){var t=s(e),n=r(e),o=e.ownerDocument.body,i=Math.max(t.scrollWidth,t.clientWidth,o?o.scrollWidth:0,o?o.clientWidth:0),a=Math.max(t.scrollHeight,t.clientHeight,o?o.scrollHeight:0,o?o.clientHeight:0),p=-n.scrollLeft+f(e),l=-n.scrollTop;return"rtl"===c(o||t).direction&&(p+=Math.max(t.clientWidth,o?o.clientWidth:0)-i),{width:i,height:a,x:p,y:l}}(s(e)))}// A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
// Gets the maximum area that the element is visible in due to any number of
// clipping parents
function V(e,t,n){var r="clippingParents"===t?function(e){var t=h(d(e)),n=["absolute","fixed"].indexOf(c(e).position)>=0&&i(e)?v(e):e;return o(n)?t.filter((function(e){return o(e)&&C(e,n)&&"body"!==a(e)})):[];// $FlowFixMe: https://github.com/facebook/flow/issues/1414
}(e):[].concat(t),s=[].concat(r,[n]),f=s[0],p=s.reduce((function(t,n){var r=I(e,n);return t.top=Math.max(r.top,t.top),t.right=Math.min(r.right,t.right),t.bottom=Math.min(r.bottom,t.bottom),t.left=Math.max(r.left,t.left),t}),I(e,f));return p.width=p.right-p.left,p.height=p.bottom-p.top,p.x=p.left,p.y=p.top,p}function _(e){return e.split("-")[1]}function N(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function U(e){var t,n=e.reference,r=e.element,o=e.placement,i=o?H(o):null,a=o?_(o):null,s=n.x+n.width/2-r.width/2,f=n.y+n.height/2-r.height/2;switch(i){case y:t={x:s,y:n.y-r.height};break;case w:t={x:s,y:n.y+n.height};break;case x:t={x:n.x+n.width,y:f};break;case O:t={x:n.x-r.width,y:f};break;default:t={x:n.x,y:n.y}}var c=i?N(i):null;if(null!=c){var p="y"===c?"height":"width";switch(a){case S:t[c]=Math.floor(t[c])-Math.floor(n[p]/2-r[p]/2);break;case M:t[c]=Math.floor(t[c])+Math.ceil(n[p]/2-r[p]/2)}}return t}function F(e){return Object.assign(Object.assign({},{top:0,right:0,bottom:0,left:0}),e)}function z(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}function G(e,n){void 0===n&&(n={});var r=n,i=r.placement,a=void 0===i?e.placement:i,f=r.boundary,c=void 0===f?"clippingParents":f,p=r.rootBoundary,l=void 0===p?P:p,u=r.elementContext,d=void 0===u?D:u,m=r.altBoundary,h=void 0!==m&&m,b=r.padding,g=void 0===b?0:b,v=F("number"!=typeof g?g:z(g,E)),O=d===D?"reference":D,j=e.elements.reference,S=e.rects.popper,M=e.elements[h?O:d],k=V(o(M)?M:M.contextElement||s(e.elements.popper),c,l),q=t(j),L=U({reference:q,element:S,strategy:"absolute",placement:a}),A=R(Object.assign(Object.assign({},S),L)),T=d===D?A:q,B={top:k.top-T.top+v.top,bottom:T.bottom-k.bottom+v.bottom,left:k.left-T.left+v.left,right:T.right-k.right+v.right},W=e.modifiersData.offset;// Offsets can be applied only to the popper element
if(d===D&&W){var H=W[a];Object.keys(B).forEach((function(e){var t=[x,w].indexOf(e)>=0?1:-1,n=[y,w].indexOf(e)>=0?"y":"x";B[e]+=H[n]*t}))}return B}var X="Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.",Y={placement:"bottom",modifiers:[],strategy:"absolute"};function J(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return!t.some((function(e){return!(e&&"function"==typeof e.getBoundingClientRect)}))}function K(e){void 0===e&&(e={});var t=e,n=t.defaultModifiers,r=void 0===n?[]:n,i=t.defaultOptions,a=void 0===i?Y:i;return function(e,t,n){void 0===n&&(n=a);var i,s,f={placement:"bottom",orderedModifiers:[],options:Object.assign(Object.assign({},Y),a),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},p=[],d=!1,m={state:f,setOptions:function(n){b(),f.options=Object.assign(Object.assign(Object.assign({},a),f.options),n),f.scrollParents={reference:o(e)?h(e):e.contextElement?h(e.contextElement):[],popper:h(t)};// Orders the modifiers based on their dependencies and `phase`
// properties
var i=function(e){
// order based on dependencies
var t=A(e);// order based on phase
return L.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}(function(e){var t=e.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign(Object.assign(Object.assign({},n),t),{},{options:Object.assign(Object.assign({},n.options),t.options),data:Object.assign(Object.assign({},n.data),t.data)}):t,e}),{});// IE11 does not support Object.values
return Object.keys(t).map((function(e){return t[e]}))}([].concat(r,f.options.modifiers)));// Strip out disabled modifiers
(f.orderedModifiers=i.filter((function(e){return e.enabled})),function(e){e.forEach((function(t){Object.keys(t).forEach((function(n){switch(n){case"name":"string"!=typeof t.name&&console.error(T(B,String(t.name),'"name"','"string"','"'+String(t.name)+'"'));break;case"enabled":"boolean"!=typeof t.enabled&&console.error(T(B,t.name,'"enabled"','"boolean"','"'+String(t.enabled)+'"'));case"phase":L.indexOf(t.phase)<0&&console.error(T(B,t.name,'"phase"',"either "+L.join(", "),'"'+String(t.phase)+'"'));break;case"fn":"function"!=typeof t.fn&&console.error(T(B,t.name,'"fn"','"function"','"'+String(t.fn)+'"'));break;case"effect":"function"!=typeof t.effect&&console.error(T(B,t.name,'"effect"','"function"','"'+String(t.fn)+'"'));break;case"requires":Array.isArray(t.requires)||console.error(T(B,t.name,'"requires"','"array"','"'+String(t.requires)+'"'));break;case"requiresIfExists":Array.isArray(t.requiresIfExists)||console.error(T(B,t.name,'"requiresIfExists"','"array"','"'+String(t.requiresIfExists)+'"'));break;case"options":case"data":break;default:console.error('PopperJS: an invalid property has been provided to the "'+t.name+'" modifier, valid properties are '+W.map((function(e){return'"'+e+'"'})).join(", ")+'; but "'+n+'" was provided.')}t.requires&&t.requires.forEach((function(n){null==e.find((function(e){return e.name===n}))&&console.error(T('Popper: modifier "%s" requires "%s", but "%s" modifier is not available',String(t.name),n,n))}))}))}))}((s=[].concat(i,f.options.modifiers),l=function(e){return e.name},u=new Set,s.filter((function(e){var t=l(e);if(!u.has(t))return u.add(t),!0})))),H(f.options.placement)===j)&&(f.orderedModifiers.find((function(e){return"flip"===e.name}))||console.error(['Popper: "auto" placements require the "flip" modifier be',"present and enabled to work."].join(" ")));var s,l,u,d=c(t);// We no longer take into account `margins` on the popper, and it can
// cause bugs with positioning, so we'll warn the consumer
return[d.marginTop,d.marginRight,d.marginBottom,d.marginLeft].some((function(e){return parseFloat(e)}))&&console.warn(['Popper: CSS "margin" styles cannot be used to apply padding',"between the popper and its reference element or boundary.","To replicate margin, use the `offset` modifier, as well as","the `padding` option in the `preventOverflow` and `flip`","modifiers."].join(" ")),f.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,o=e.effect;if("function"==typeof o){var i=o({state:f,name:t,instance:m,options:r}),a=function(){};p.push(i||a)}})),m.update()},
// Sync update – it will always be executed, even if not necessary. This
// is useful for low frequency updates where sync behavior simplifies the
// logic.
// For high frequency updates (e.g. `resize` and `scroll` events), always
// prefer the async Popper#update method
forceUpdate:function(){if(!d){var e=f.elements,t=e.reference,n=e.popper;// Don't proceed if `reference` or `popper` are not valid elements
// anymore
if(J(t,n)){// Store the reference and popper rects to be read by modifiers
f.rects={reference:l(t,v(n),"fixed"===f.options.strategy),popper:u(n)},// Modifiers have the ability to reset the current update cycle. The
// most common use case for this is the `flip` modifier changing the
// placement, which then needs to re-run all the modifiers, because the
// logic was previously ran for the previous placement and is therefore
// stale/incorrect
f.reset=!1,f.placement=f.options.placement,// On each update cycle, the `modifiersData` property for each modifier
// is filled with the initial data specified by the modifier. This means
// it doesn't persist and is fresh on each update.
// To ensure persistent data, use `${name}#persistent`
f.orderedModifiers.forEach((function(e){return f.modifiersData[e.name]=Object.assign({},e.data)}));for(var r=0,o=0;o<f.orderedModifiers.length;o++){if((r+=1)>100){console.error("Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.");break}if(!0!==f.reset){var i=f.orderedModifiers[o],a=i.fn,s=i.options,c=void 0===s?{}:s,p=i.name;"function"==typeof a&&(f=a({state:f,options:c,name:p,instance:m})||f)}else f.reset=!1,o=-1}}else console.error(X)}},
// Async and optimistically optimized update – it will not be executed if
// not necessary (debounced to run at most once-per-tick)
update:(i=function(){return new Promise((function(e){m.forceUpdate(),e(f)}))},function(){return s||(s=new Promise((function(e){Promise.resolve().then((function(){s=void 0,e(i())}))}))),s}),destroy:function(){b(),d=!0}};if(!J(e,t))return console.error(X),m;function b(){p.forEach((function(e){return e()})),p=[]}return m.setOptions(n).then((function(e){!d&&n.onFirstUpdate&&n.onFirstUpdate(e)})),m}}var Q={passive:!0};// eslint-disable-next-line import/no-unused-modules
var Z={top:"auto",right:"auto",bottom:"auto",left:"auto"};function $(e){var t,r=e.popper,o=e.popperRect,i=e.placement,a=e.offsets,f=e.position,c=e.gpuAcceleration,p=e.adaptive,l=// Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function(e){var t=e.x,n=e.y,r=window.devicePixelRatio||1;return{x:Math.round(t*r)/r||0,y:Math.round(n*r)/r||0}}(a),u=l.x,d=l.y,m=a.hasOwnProperty("x"),h=a.hasOwnProperty("y"),b=O,g=y,j=window;if(p){var E=v(r);E===n(r)&&(E=s(r)),// $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
/*:: offsetParent = (offsetParent: Element); */
i===y&&(g=w,d-=E.clientHeight-o.height,d*=c?1:-1),i===O&&(b=x,u-=E.clientWidth-o.width,u*=c?1:-1)}var S,M=Object.assign({position:f},p&&Z);return c?Object.assign(Object.assign({},M),{},((S={})[g]=h?"0":"",S[b]=m?"0":"",S.transform=(j.devicePixelRatio||1)<2?"translate("+u+"px, "+d+"px)":"translate3d("+u+"px, "+d+"px, 0)",S)):Object.assign(Object.assign({},M),{},((t={})[g]=h?d+"px":"",t[b]=m?u+"px":"",t.transform="",t))}// eslint-disable-next-line import/no-unused-modules
var ee={left:"right",right:"left",bottom:"top",top:"bottom"};function te(e){return e.replace(/left|right|bottom|top/g,(function(e){return ee[e]}))}var ne={start:"end",end:"start"};function re(e){return e.replace(/start|end/g,(function(e){return ne[e]}))}
/*:: type OverflowsMap = { [ComputedPlacement]: number }; */
/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */function oe(e,t){void 0===t&&(t={});var n=t,r=n.placement,o=n.boundary,i=n.rootBoundary,a=n.padding,s=n.flipVariations,f=n.allowedAutoPlacements,c=void 0===f?q:f,p=_(r),l=p?s?k:k.filter((function(e){return _(e)===p})):E,u=l.filter((function(e){return c.indexOf(e)>=0}));0===u.length&&(u=l,console.error(["Popper: The `allowedAutoPlacements` option did not allow any","placements. Ensure the `placement` option matches the variation","of the allowed placements.",'For example, "auto" cannot be used to allow "bottom-start".','Use "auto-start" instead.'].join(" ")));// $FlowFixMe: Flow seems to have problems with two array unions...
var d=u.reduce((function(t,n){return t[n]=G(e,{placement:n,boundary:o,rootBoundary:i,padding:a})[H(n)],t}),{});return Object.keys(d).sort((function(e,t){return d[e]-d[t]}))}function ie(e,t,n){return Math.max(e,Math.min(t,n))}function ae(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function se(e){return[y,x,w,O].some((function(t){return e[t]>=0}))}// eslint-disable-next-line import/no-unused-modules
var fe=[{name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var t=e.state,r=e.instance,o=e.options,i=o.scroll,a=void 0===i||i,s=o.resize,f=void 0===s||s,c=n(t.elements.popper),p=[].concat(t.scrollParents.reference,t.scrollParents.popper);return a&&p.forEach((function(e){e.addEventListener("scroll",r.update,Q)})),f&&c.addEventListener("resize",r.update,Q),function(){a&&p.forEach((function(e){e.removeEventListener("scroll",r.update,Q)})),f&&c.removeEventListener("resize",r.update,Q)}}// eslint-disable-next-line import/no-unused-modules
,data:{}},{name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;// Offsets are the actual position the popper needs to have to be
// properly positioned near its reference element
// This is the most basic placement, and will be adjusted by
// the modifiers in the next step
t.modifiersData[n]=U({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement})},data:{}},{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,o=void 0===r||r,i=n.adaptive,a=void 0===i||i,s=c(t.elements.popper).transitionProperty||"";a&&["transform","top","right","bottom","left"].some((function(e){return s.indexOf(e)>=0}))&&console.warn(["Popper: Detected CSS transitions on at least one of the following",'CSS properties: "transform", "top", "right", "bottom", "left".',"\n\n",'Disable the "computeStyles" modifier\'s `adaptive` option to allow',"for smooth transitions, or remove these properties from the CSS","transition declaration on the popper element if only transitioning","opacity or background-color for example.","\n\n","We recommend using the popper element as a wrapper around an inner","element that can have any CSS property transitioned for animations."].join(" "));var f={placement:H(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:o};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign(Object.assign({},t.styles.popper),$(Object.assign(Object.assign({},f),{},{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:a})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign(Object.assign({},t.styles.arrow),$(Object.assign(Object.assign({},f),{},{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1})))),t.attributes.popper=Object.assign(Object.assign({},t.attributes.popper),{},{"data-popper-placement":t.placement})}// eslint-disable-next-line import/no-unused-modules
,data:{}},{name:"applyStyles",enabled:!0,phase:"write",fn:// and applies them to the HTMLElements such as popper and arrow
function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},r=t.attributes[e]||{},o=t.elements[e];// arrow is optional + virtual elements
i(o)&&a(o)&&(// Flow doesn't support to extend this property, but it's the most
// effective way to apply styles to an HTMLElement
// $FlowFixMe
Object.assign(o.style,n),Object.keys(r).forEach((function(e){var t=r[e];!1===t?o.removeAttribute(e):o.setAttribute(e,!0===t?"":t)})))}))},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var r=t.elements[e],o=t.attributes[e]||{},s=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});// arrow is optional + virtual elements
i(r)&&a(r)&&(// Flow doesn't support to extend this property, but it's the most
// effective way to apply styles to an HTMLElement
// $FlowFixMe
Object.assign(r.style,s),Object.keys(o).forEach((function(e){r.removeAttribute(e)})))}))}}// eslint-disable-next-line import/no-unused-modules
,requires:["computeStyles"]},{name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,o=n.offset,i=void 0===o?[0,0]:o,a=q.reduce((function(e,n){return e[n]=function(e,t,n){var r=H(e),o=[O,y].indexOf(r)>=0?-1:1,i="function"==typeof n?n(Object.assign(Object.assign({},t),{},{placement:e})):n,a=i[0],s=i[1];return a=a||0,s=(s||0)*o,[O,x].indexOf(r)>=0?{x:s,y:a}:{x:a,y:s}}(n,t.rects,i),e}),{}),s=a[t.placement],f=s.x,c=s.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=f,t.modifiersData.popperOffsets.y+=c),t.modifiersData[r]=a}},{name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var o=n.mainAxis,i=void 0===o||o,a=n.altAxis,s=void 0===a||a,f=n.fallbackPlacements,c=n.padding,p=n.boundary,l=n.rootBoundary,u=n.altBoundary,d=n.flipVariations,m=void 0===d||d,h=n.allowedAutoPlacements,b=t.options.placement,g=H(b),v=f||(g===b||!m?[te(b)]:function(e){if(H(e)===j)return[];var t=te(e);return[re(e),t,re(t)]}(b)),E=[b].concat(v).reduce((function(e,n){return e.concat(H(n)===j?oe(t,{placement:n,boundary:p,rootBoundary:l,padding:c,flipVariations:m,allowedAutoPlacements:h}):n)}),[]),M=t.rects.reference,P=t.rects.popper,D=new Map,k=!0,q=E[0],L=0;L<E.length;L++){var A=E[L],T=H(A),B=_(A)===S,W=[y,w].indexOf(T)>=0,C=W?"width":"height",R=G(t,{placement:A,boundary:p,rootBoundary:l,altBoundary:u,padding:c}),I=W?B?x:O:B?w:y;M[C]>P[C]&&(I=te(I));var V=te(I),N=[];if(i&&N.push(R[T]<=0),s&&N.push(R[I]<=0,R[V]<=0),N.every((function(e){return e}))){q=A,k=!1;break}D.set(A,N)}if(k)for(
// `2` may be desired in some cases – research later
var U=function(e){var t=E.find((function(t){var n=D.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return q=t,"break"},F=m?3:1;F>0;F--){if("break"===U(F))break}t.placement!==q&&(t.modifiersData[r]._skip=!0,t.placement=q,t.reset=!0)}}// eslint-disable-next-line import/no-unused-modules
,requiresIfExists:["offset"],data:{_skip:!1}},{name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,o=n.mainAxis,i=void 0===o||o,a=n.altAxis,s=void 0!==a&&a,f=n.boundary,c=n.rootBoundary,p=n.altBoundary,l=n.padding,d=n.tether,m=void 0===d||d,h=n.tetherOffset,b=void 0===h?0:h,g=G(t,{boundary:f,rootBoundary:c,padding:l,altBoundary:p}),j=H(t.placement),E=_(t.placement),M=!E,P=N(j),D="x"===P?"y":"x",k=t.modifiersData.popperOffsets,q=t.rects.reference,L=t.rects.popper,A="function"==typeof b?b(Object.assign(Object.assign({},t.rects),{},{placement:t.placement})):b,T={x:0,y:0};if(k){if(i){var B="y"===P?y:O,W="y"===P?w:x,C="y"===P?"height":"width",R=k[P],I=k[P]+g[B],V=k[P]-g[W],U=m?-L[C]/2:0,F=E===S?q[C]:L[C],z=E===S?-L[C]:-q[C],X=t.elements.arrow,Y=m&&X?u(X):{width:0,height:0},J=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},K=J[B],Q=J[W],Z=ie(0,q[C],Y[C]),$=M?q[C]/2-U-Z-K-A:F-Z-K-A,ee=M?-q[C]/2+U+Z+Q+A:z+Z+Q+A,te=t.elements.arrow&&v(t.elements.arrow),ne=te?"y"===P?te.clientTop||0:te.clientLeft||0:0,re=t.modifiersData.offset?t.modifiersData.offset[t.placement][P]:0,oe=k[P]+$-re-ne,ae=k[P]+ee-re,se=ie(m?Math.min(I,oe):I,R,m?Math.max(V,ae):V);k[P]=se,T[P]=se-R}if(s){var fe="x"===P?y:O,ce="x"===P?w:x,pe=k[D],le=ie(pe+g[fe],pe,pe-g[ce]);k[D]=le,T[D]=le-pe}t.modifiersData[r]=T}}// eslint-disable-next-line import/no-unused-modules
,requiresIfExists:["offset"]},{name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,o=n.elements.arrow,i=n.modifiersData.popperOffsets,a=H(n.placement),s=N(a),f=[O,x].indexOf(a)>=0?"height":"width";if(o&&i){var c=n.modifiersData[r+"#persistent"].padding,p=u(o),l="y"===s?y:O,d="y"===s?w:x,m=n.rects.reference[f]+n.rects.reference[s]-i[s]-n.rects.popper[f],h=i[s]-n.rects.reference[s],b=v(o),g=b?"y"===s?b.clientHeight||0:b.clientWidth||0:0,j=m/2-h/2,E=c[l],S=g-p[f]-c[d],M=g/2-p[f]/2+j,P=ie(E,M,S),D=s;n.modifiersData[r]=((t={})[D]=P,t.centerOffset=P-M,t)}},effect:function(e){var t=e.state,n=e.options,r=e.name,o=n.element,a=void 0===o?"[data-popper-arrow]":o,s=n.padding,f=void 0===s?0:s;null!=a&&("string"!=typeof a||(a=t.elements.popper.querySelector(a)))&&(i(a)||console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).',"To use an SVG arrow, wrap it in an HTMLElement that will be used as","the arrow."].join(" ")),C(t.elements.popper,a)?(t.elements.arrow=a,t.modifiersData[r+"#persistent"]={padding:F("number"!=typeof f?f:z(f,E))}):console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper',"element."].join(" ")));// CSS selector
}// eslint-disable-next-line import/no-unused-modules
,requires:["popperOffsets"],requiresIfExists:["preventOverflow"]},{name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,o=t.rects.popper,i=t.modifiersData.preventOverflow,a=G(t,{elementContext:"reference"}),s=G(t,{altBoundary:!0}),f=ae(a,r),c=ae(s,o,i),p=se(f),l=se(c);t.modifiersData[n]={referenceClippingOffsets:f,popperEscapeOffsets:c,isReferenceHidden:p,hasPopperEscaped:l},t.attributes.popper=Object.assign(Object.assign({},t.attributes.popper),{},{"data-popper-reference-hidden":p,"data-popper-escaped":l})}}],ce=K({defaultModifiers:fe});// eslint-disable-next-line import/no-unused-modules
e.createPopper=ce,e.defaultModifiers=fe,e.detectOverflow=G,e.popperGenerator=K,Object.defineProperty(e,"__esModule",{value:!0})}));